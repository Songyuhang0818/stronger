---
title: 浏览器知识
author: songyuhang
date: 2021-12-13
tags:
  - 浏览器知识
---

## 1.进程和线程

一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。

线程是不能单独存在的，它是由进程来启动和管理的。

线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。

1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。
2. 线程之间共享进程中的数据。
3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。
4. 进程之间内容隔离

## 2.最新谷歌浏览器

最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。

下面我们来逐个分析下这几个进程的功能。

- 浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
- GPU 进程。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
- 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
- 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

## 3.浏览器端发起 HTTP 请求流程

HTTP 是一种允许浏览器向服务器获取资源的协议

### 1. 构建请求

```js
GET /index.html HTTP1.1
```

### 2. 查找缓存

在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。其中，浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。
当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。这样做的好处有：

缓解服务器端压力，提升性能（获取资源的耗时更短了）；
对于网站来说，缓存是实现快速资源加载的重要组成部分。
当然，如果缓存查找失败，就会进入网络请求过程了。

### 3. 准备 IP 地址和端口

浏览器会请求 DNS 返回域名对应的 IP，当然浏览器还提供了 DNS 数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。

### 4. 等待 TCP 队列

现在已经把端口和 IP 地址都准备好了，那么下一步是不是可以建立 TCP 连接了呢？

答案依然是“不行”。Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。

当然，如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。

### 5. 建立 TCP 连接

### 6. 发送 HTTP 请求

首先浏览器会向服务器发送请求行，它包括了请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议。

### 7. 服务器端处理 HTTP 请求流程

1. 返回请求
   服务器会返回响应行，包括协议版本和状态码。

2. 断开连接
   通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。
   如果返回头中含有

```js
Connection: Keep - Alive;
```

那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。

3. 重定向

响应行返回的状态码是 301，状态 301 就是告诉浏览器，我需要重定向到另外一个网址，而需要重定向的网址正是包含在响应头的 Location 字段中

## 4.浏览器缓存

### DNS 缓存和页面资源缓存

1. DNS 缓存比较简单，它主要就是在浏览器本地把对应的 IP 和域名关联起来

2. 先从本地缓存中查找结果以及缓存标识，根据缓存标识判断是否使用本地缓存，如果缓存有效，则使用本地缓存，否则向服务器发请求并且携带缓存标识。根据是否向浏览器发
   器 Http 请求，将缓存过程分为两个部分 强缓存和协商缓存，强缓存优于协商缓存。

- **强缓存**，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求直接用缓存，否则执行比较缓存策略。
- **协商缓存**，让客户端和服务器之间能实现缓存文件是否更新的验证，提升缓存的复用率，将缓存信息中的 `ETag` 和 `Last-Modified` 通过请求发送给服务器，由服务器校验，返回 304 状态码时，浏览器直接使用缓存。

HTTP 缓存都是从第二次请求开始的:

- 第一次请求资源时，服务器返回资源，在 `Response header` 中返回资源的缓存策略。
- 第二次请求时，浏览器判断这些请求参数，击中强缓存返回 200，否则把请求参数添加到 `Request header` 中传给服务器，看是否击中协商缓存，击中则返回 304，否则返回新的资源。

#### 强缓存

- 强缓存命中，在 network 中显示 from memory 或者 from disk。
- 控制强缓存的字段: `Cache-Control`(http1.1) 和 `Expires`(http1.0)。
- `Cache-Control` 是一个相对时间，表示上次正确请求的后多少秒的时间段内缓存有效。
- `Expires` 是一个绝对时间，表示在这个时间之前都从缓存里读数据，无需发请求。
- `Cache-Control` 优先于 `Expires`，前者是为了解决手动修改 `Expires` 导致缓存判断错误的问题，同时存在时使用 `Cache-Control`。

`Cache-Control` 常用的值为：

- `max-age`: 最大有效时间
- `must-revalidate`: 超过`max-age`的时间，浏览器必须向服务器发送请求，验证资源是否还有效。
- `no-cache`: 不使用强缓存，需要与服务器验证缓存是否新鲜。
- `no-store`: 真正意义的不使用缓存，所有内容都不走缓存，包括强制与对比。
- `public`: 所有内容都可以被缓存(包括客户端和代理服务器，如 CDN)
- `private`: 所用内容只有客户端可以缓存，代理服务器不能缓存。

- 到期

  - `max-age=<seconds\>`
    - 缓存到期时间
  - `s-maxage=<seconds\>`
    - 代理服务器专用
  - `5`
    - 指示客户机可以使用超出 max-age 时间的响应

  重新验证

  - must-revalidate
    - 设置了 max-age 的资源过期后必须到源服务端验证资源是否还可用
  - proxy-revalidate
    - （缓存服务器用）设置了 max-age 的资源过期后必须到源服务端验证资源是否还可用

#### 协商缓存

- 协商缓存的状态码由服务器决策返回 200 或者 304
- 浏览器设置不走强缓存或者强缓存失效，并且请求头中设置了`If-Modified-Since`或者`If-None-Match`时，会将这两个值带到服务器端去验证是否命中协商缓存，如果命中，返回 304，加载浏览器缓存，并且响应头会设置`Last-Modified`或者`ETag`属性
- `Last-Modified/If-Modified-Since`(http1.0)表示服务器的资源最后一次修改的时间
- `ETag/If-None-Match`(http1.1)表示服务器资源的唯一标识，只要资源变化，ETag 就会重新生成
- `ETag/If-None-Match`比`Last-Modified/If-Modified-Since`优先级高

- `Last-Modified/If-Modified-Since`

  - 服务器通过`Last-Modified`字段告知客户端资源最后一次被修改的时间，例如`Last-Modified: Mon, 10 Nov 2021 08:24:00 GMT`
  - 浏览器将这个值和内容一起记录在缓存数据库中。
  - 下一次请求相同资源时，浏览器从自己的缓存中找出不确实是否过期的缓存，因此请求头中将上次的`Last-Modified`值写入到`If-Modified-Since`字段。
  - 服务器会将`If-Modified-Since`的值与`Last-Modified`字段进行对比，如果相等，表示未修改，返回 304，否则返回 200，返回新数据
  - 优点
    - 不存在版本问题，每次请求都会去服务器校验
  - 缺点
    - 只要资源修改，无论是否发生实质性的变化，都会将该资源返回给客户端，例如周期性重写
    - 因为以时刻作为标识，最小单位是秒，无法判断一秒内多次修改的情况，
    - 某些服务器不能精确得到文件最后的修改时间
    - 如果文件是通过服务器动态生成的，那么该方法的更新永远是生成的时间，尽管文件可能没有变化，所以起不到缓存作用。

- `ETag/If-None-Match`
  - `ETag`存储的是文件的特殊标识(一般都是 hash 生成的)，其余与 Last-Modified 一致，只不过把时间改为了`ETag`以及他表示的文件的 hash
  - `ETag`优先级高于`Last-Modified`
  - 优点
    - 可以更精确的判断资源是否被修改，可以识别一秒内的多次修改
    - 不存在版本问题，每次请求都会去服务器校验
  - 缺点
    - 计算`ETag`值消耗性能
    - 分布式服务器存储的情况下，计算的`ETag`的算法如果不一样，会导致浏览球从一台服务器上获得页面内容后到另外一台服务器进行验证时不匹配
